#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
prepGridMask.py

VERSION AND LAST UPDATE:
 v1.0  04/04/2022
 v1.1  05/03/2022
 v1.2  05/17/2023
 v1.3  10/15/2024

PURPOSE:
 This program creates a grid mask to identify coastal points and 
  open/deep water areas, based on water depth and distance to the coast.
 This is useful for model validation against satellite data,
  where coastal areas should be excluded. For validation using buoy data,
  it allows to run specific assessments comparing deep water with 
  coastal areas.

USAGE:
 The grid mask uses the same resolution (lat/lon arrays) as 
  the ww3 sample file (see xr.open_dataset below and edit file name) that
  must be given by the user (where lat/lon arrays are defined)
 The file distFromCoast.nc was generated by organizeDistanceToCoast.py
  and, if not downloaded during ww3-tools installation, you can find it at:
  https://noaa-nws-gefswaves-reforecast-pds.s3.amazonaws.com/index.html#GEFSv12/gridinfo/
  as well as the etopo1.nc containing the bathymetry
 You can replace etopo1.nc bathymetry by any other source, such as GEBCO,
  or bluetopo; just pay attention to longitude standards (-180to180 or 0to360).
  Both distFromCoast.nc and etopo1.nc must be in the same directory you are
  running this code (or symbolic link, ln -s).

 By default, this program generates output figures to check everything looks
  correct. You can choose not to generate any figure by switching pfig below
  to any value different than 1.
 Pre-defined values of mindepth and mindfc can be edited below (see mindepth,
  and mindfc), as well as the prefix name for the outputs (figures and netcdf),
  gridn

 Example (from linux terminal command line):
  nohup python3 prepGridMask.py >> nohup_prepGridMask.out 2>&1 &

OUTPUT:
 netcdf file gridInfo_*.nc containing:
  mask info identifying land, ocean points, and coastal points.
  distance to the nearest coast
  water depth
 figures illustrating these fields

DEPENDENCIES:
 See setup.py and the imports below.
 ww3 sample file (change name in the xr.open_dataset)
 distFromCoast.nc generated by organizeDistanceToCoast.py
 bathymetry (etopo is used by default)
 You can download etopo1.nc, distFromCoast.nc, and the shapefiles directly at:
 https://noaa-nws-gefswaves-reforecast-pds.s3.amazonaws.com/index.html#GEFSv12/gridinfo/

AUTHOR and DATE:
 04/04/2022: Ricardo M. Campos, first version.
 05/03/2022: Ricardo M. Campos, allow users to choose if they want to
   process ocean names and forecast areas or not (as it take some time).
 05/17/2023: Ricardo M. Campos, ww3 MAPSTA set as optional, figures can
   now be swiched off (pfig=0), and it saves the netcdf file first.
 10/15/2024: Ricardo M. Campos, remove ocean names and forecast area names to
   remove dependency on shapefiles

PERSON OF CONTACT:
 Ricardo M Campos: ricardo.campos@noaa.gov

"""
import pylab
from pylab import *
from matplotlib.mlab import *
import numpy as np
import xarray as xr
import netCDF4 as nc
from matplotlib import ticker
import xarray
import warnings; warnings.filterwarnings("ignore")
# netcdf format
fnetcdf="NETCDF4"

# --------------------
# Grid Name and prefix
gridn='MOD'
# Minimum water depth
mindepth=50. # in meters
# Minimum distance from the coast
mindfc=25. # in Km
# Flag to generate plots and save figures (1) or not (0)
pfig=1
# Output path where results will be saved
outpath='/home/ricardo/work/noaa/analysis/TC_Waves/1preproc/mask'
# -----------------


# Target Lat Lon arrays - TC maps domain and WTCM and PModel resolution
lat = np.arange(-1,51,0.05)
lon = np.arange(169,351,0.05)
print(' Target lat lon: OK')

# mask[850:1025,:][:,1960:2300] = np.nan # Mask Great lakes.
# mask[950:1030,:][:,2380:2522] = np.nan
# mask[735:760,:][:,1460:1500] = np.nan

# Interpolate ww3 mask to target lat lon
# Sample ww3 file (reference) lat lon array
fsname='gdaswave.20231120.global.0p16.nc'
ds=xr.open_dataset(fsname)
glat = ds['latitude'].values[:]; glon = ds['longitude'].values[:]; glon[glon<0]=glon[glon<0]+360.
hs = np.array(ds['HTSGW_surface'][0,:,:].interp(latitude=lat[:], longitude=lon[:], method='linear'))
ds.close(); del ds
hs[hs>=0.0001]=1; hs[:,0:250]=1
hs[np.isnan(hs)==True]=0

print(' ')
print(' read model sample and interpolate: OK')

# ====== BATHYMETRY Etopo grid ==============
ds = xr.open_dataset('etopo1.nc')
latb = ds['lat'].values[:]; lonb = ds['lon'].values[:]
b = ds['z'].values[:,:]
# interpolate Bathymetry to Model
dsi = ds.interp(lat=lat[:], lon=lon[:], method='linear')
ib = dsi['z'].values[:,:]
ds.close(); del ds, dsi
print(' read bathymetry: OK')

# ======  Distance to the Coast ==============
ds = xr.open_dataset('distFromCoast.nc')
latd = ds['latitude'].values[:]; lond = ds['longitude'].values[:]
dfc = ds['distcoast'].values[:,:]
# interpolate to Model
dsc = ds.interp(latitude=lat[:], longitude=lon[:], method="linear")
idfc = dsc['distcoast'].values[:,:]; ds.close(); del ds, dsc
print(' read distance to coast: OK')

# Build Mask (nan = land excluded; 0 = ocean excluded; 1 = ocean valid)
mask = np.zeros((lat.shape[0],lon.shape[0]),'f')
# ind = np.where((ib>0) | (hs==0)); mask[ind[0],ind[1]] = np.nan; del ind
ind = np.where((ib>0)); mask[ind[0],ind[1]] = np.nan; del ind
# excluding based on depth and dist-to-coast criteria
# ind = np.where( (ib<=(-1*mindepth)) & (idfc>=mindfc) & (np.isnan(mask)==False) ); mask[ind[0],ind[1]] = 1; del ind
ind = np.where( (ib<=(-1*mindepth)) & (idfc>=mindfc) ); mask[ind[0],ind[1]] = 1; del ind
print(' grid mask: OK')
print(' '); print(' Done! Final plots and netcdf output file ...')

# ================== SAVE NETCDF FILE ==================

if outpath[-1] != '/':
	outpath=outpath+"/"

# Water depth is positive, by definition
ib = np.array(ib*-1); ib[ib<0]=np.nan; ib[np.isnan(mask)==True]=np.nan
idfc[np.isnan(ib)==True]=np.nan

ncfile = nc.Dataset(outpath+'gridInfo_'+gridn+'.nc', "w", format=fnetcdf) 
ncfile.description='Bathymetry, Distance from the coast and Mask. Total of '+repr(mask[mask>=0].shape[0])+' Ocean grid points, and '+repr(mask[mask>0].shape[0])+' valid ocean grid points to use.'
# dimensions.
ncfile.createDimension( 'latitude' , lat.shape[0] ); ncfile.createDimension( 'longitude' , lon.shape[0] )
# create  variables
lats = ncfile.createVariable('latitude',np.dtype('float32').char,('latitude',))
lons = ncfile.createVariable('longitude',np.dtype('float32').char,('longitude',))
# main fields
vdfc = ncfile.createVariable('distcoast',np.dtype('float32').char,('latitude','longitude'))
vib = ncfile.createVariable('depth',np.dtype('float32').char,('latitude','longitude'))
vmask = ncfile.createVariable('mask',np.dtype('float32').char,('latitude','longitude'))
# Assign units attributes
vdfc.units = 'km'
vib.units = 'm'
lats.units = 'degrees_north'
lons.units = 'degrees_east'
# write data to vars.
lats[:] = lat[:]; lons[:] = lon[:]
vdfc[:,:]=idfc[:,:]
vib[:,:]=ib[:,:] 
vmask[:,:]=mask[:,:]
# close the file
ncfile.close()
print('netcdf ok'); print(' ')
print('Number of Ocean points: '+repr(ib[ib>=0].shape[0]))
print('Number of valid Ocean points: '+repr(mask[mask>0].shape[0]))

# Number of Ocean points: 3093843
# Number of valid Ocean points: 2980872


print('prepGridMask.py Completed')

