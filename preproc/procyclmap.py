#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
procyclmap.py

VERSION AND LAST UPDATE:
 v1.0  04/04/2022
 v2.0  10/23/2025

PURPOSE:
 This script creates a map with cyclone information, using the gridInfo 
  (generated by preprGridMask.py) and cyclone tracks from IBTracks.
 The cyclone information is provided on the grid gridInfo.nc, where
  lat/lon is taken. This scripts is run for one year (input argument)
  and the output netcdf file has 3-hourly resolution.

USAGE:
 It reads an argument with the year of interest.
 The file ibtracs.since1980.list.v04r00.csv must be saved (or symbolic link)
 Example:
  python3 procyclmap.py 2010
  nohup python3 procyclmap.py 2019 >> nohup_cyclmap_2019.out 2>&1 &

OUTPUT:
 netcdf file with integers where, for each grid point and time:
 0(no cyclone); 1(Missing,conflicting,or not reported); 
 2(disturbance); 3(extratropical); 4(subtropical storm/cyclone); 
 5(tropical storm/cyclone)
 located at the grid informed by gridInfo.nc, for one year 
 (input argument), with 3-hourly results.

DEPENDENCIES:
 See setup.py and the imports below.
 gridInfo.nc generated by preprGridMask.py
 IBTRACKS V4 data. It can be downloaded at
  https://www.ncei.noaa.gov/data/international-best-track-archive-for-climate-stewardship-ibtracs/v04r00/access/csv/
  https://www.ncdc.noaa.gov/ibtracs/index.php?name=bib

AUTHOR and DATE:
 04/04/2022: Ricardo M. Campos, first version.

PERSON OF CONTACT:
 Ricardo M Campos: ricardo.campos@noaa.gov

"""

import pylab
from pylab import *
from matplotlib.mlab import *
import geopy.distance
from scipy.interpolate import griddata
import netCDF4 as nc
import pandas as pd
import numpy as np
import sys
import time
from calendar import timegm
import matplotlib.pyplot as plt
import pandas as pd
import warnings; warnings.filterwarnings("ignore")
fnetcdf="NETCDF4_CLASSIC"

# Auxiliar functions ---
def bearing(lat1, lon1, lat2, lon2):
    """
    Calculate the propagation direction (going to), based on two pairs of lat/lons
    """
    lat1_rad = np.deg2rad(lat1)
    lat2_rad = np.deg2rad(lat2)
    dlon_rad = np.deg2rad(lon2 - lon1)
    x = np.sin(dlon_rad) * np.cos(lat2_rad)
    y = np.cos(lat1_rad) * np.sin(lat2_rad) - np.sin(lat1_rad) * np.cos(lat2_rad) * np.cos(dlon_rad)
    bearing_rad = np.arctan2(x, y)
    bearing_deg = (np.rad2deg(bearing_rad) + 360) % 360  # normalize to [0, 360)
    return bearing_deg

def cbearing(alat,alon):
    """
    Generate the final propagation direction (going to) for given arrays of lat and lon
    """
    alon[alon>180]=alon[alon>180]-360.
    bdir1=np.zeros(len(alat),'f')*np.nan
    bdir2=np.zeros(len(alat),'f')*np.nan
    for i in range(0,len(alat)-1):
        bdir1[i] = bearing(alat[i],alon[i],alat[i+1],alon[i+1])

    for i in range(1,len(alat)):
        bdir2[i] = bearing(alat[i-1],alon[i-1],alat[i],alon[i])

    bdir1[-1]=bdir2[-1]; bdir2[0]=bdir1[0]

    rad1 = np.deg2rad(bdir1); rad2 = np.deg2rad(bdir2)
    sin_avg = (np.sin(rad1) + np.sin(rad2)) / 2
    cos_avg = (np.cos(rad1) + np.cos(rad2)) / 2
    avg_dir_rad = np.arctan2(sin_avg, cos_avg)
    avg_dir_deg = (np.rad2deg(avg_dir_rad) + 360) % 360
    return avg_dir_deg

def rotate_field(A, lat, lon, x_dir):
    """
    Rotate the vortex based on the propagation heading (rangle).
    """
    theta = np.deg2rad(x_dir)
    lon2d, lat2d = np.meshgrid(lon, lat)
    # Center of rotation
    lat0 = np.mean(lat)
    lon0 = np.mean(lon)
    # Convert to local coordinates
    x = (lon2d - lon0) * np.cos(np.deg2rad(lat0))
    y = lat2d - lat0
    # Apply rotation
    x_rot =  x * np.cos(theta) - y * np.sin(theta)
    y_rot =  x * np.sin(theta) + y * np.cos(theta)
    # Convert back to lat/lon
    lon_rot = lon0 + x_rot / np.cos(np.deg2rad(lat0))
    lat_rot = lat0 + y_rot

    # Interpolate rotated field
    points = np.column_stack((lon2d.ravel(), lat2d.ravel()))
    values = A.ravel()
    points_new = np.column_stack((lon_rot.ravel(), lat_rot.ravel()))

    A_rot = griddata(points, values, points_new, method='nearest')
    A_rot = A_rot.reshape(A.shape)

    return A_rot  # <-- only 2D matrix returned


if __name__ == "__main__":

    # hourly data, if you want to change the time resolution, please edit the next line.
    ftime = np.array(np.arange(float(timegm( time.strptime('2022010100', '%Y%m%d%H') )),float(timegm( time.strptime('2025010100', '%Y%m%d%H') ))+1,3*3600.)).astype('double')
    # Cyclone radius (km) for tropical cyclones, followed by its transition to extratropical 
    # https://journals.ametsoc.org/view/journals/clim/29/8/jcli-d-15-0731.1.xml
    # https://www.nhc.noaa.gov/pdf/carrasco-etal-wf2014.pdf
    tcr=500.; etr=700. # etr=1000.

    # READ mask
    f=nc.Dataset('gridInfo.nc')
    latm=f.variables['latitude'][:]; lonm=f.variables['longitude'][:]; lonm[lonm>180]=lonm[lonm>180]-360.
    maskm=f.variables['mask'][:,:];
    f.close(); del f
    # -------------

    # --- Read Tracks -----
    # READ IBTRACKS V4 https://www.ncei.noaa.gov/data/international-best-track-archive-for-climate-stewardship-ibtracs/v04r00/access/csv/
    # https://www.ncdc.noaa.gov/ibtracs/index.php?name=bib
    # http://www.euro4m.eu/Presentations_ACRE/Diamond_acre_11_IBTrACS.pdf
    # https://www.fgdl.org/metadata/fgdl_html/tropc_dec13.htm
    # Storm nature: TS - storm is tropical SS - Subtropical ET - Extratropical DS - Disturbance MX - Mix of conflicting reports NR - Not Reported MM - Missing
    # pick TS,SS,DS,ET,MX/NR . Exclude MX,NR

    ity=[];itm=[];itd=[];ith=[];ilat=[];ilon=[];inat=[];icyid=[];iname=[]
    # Cyclone data
    dfibtr = pd.read_csv('ibtracs.last3years.list.v04r01.csv', header=[0,1])
    inat=np.append(inat,dfibtr.values[:,7]); ilat=np.append(ilat,dfibtr.values[:,8]); ilon=np.append(ilon,dfibtr.values[:,9])
    iname=np.array(dfibtr['NAME'].values[:][:,0]).astype('str')
    icyid=np.array(dfibtr['NUMBER'].values[:][:,0]).astype('int')
    ity=np.append(ity,np.array(pd.Series(dfibtr['ISO_TIME'].values.flatten()).str.slice(0,4)).astype('int'))
    itm=np.append(itm,np.array(pd.Series(dfibtr['ISO_TIME'].values.flatten()).str.slice(5,7)).astype('int'))
    itd=np.append(itd,np.array(pd.Series(dfibtr['ISO_TIME'].values.flatten()).str.slice(8,10)).astype('int'))
    ith=np.append(ith,np.array(pd.Series(dfibtr['ISO_TIME'].values.flatten()).str.slice(11,13)).astype('int'))
    print('Ibtracks ok'); del dfibtr
    ind=np.where(iname!="UNNAMED")
    ity=np.copy(ity[ind[0]]);itm=np.copy(itm[ind[0]]); itd=np.copy(itd[ind[0]]); ith=np.copy(ith[ind[0]])
    icyid=np.copy(icyid[ind[0]]); iname=np.copy(iname[ind[0]])
    ilat=np.copy(ilat[ind[0]]);ilon=np.copy(ilon[ind[0]]);inat=np.copy(inat[ind[0]])
    del ind
    # ilon[ilon<0]=ilon[ilon<0]+360.

    # -----------
    # Organize time
    ind=np.where((ity>=2022) & (ilat>=latm.min()) & (ilat<=latm.max()) & (ilon>=lonm.min()) & (ilon<=lonm.max()) )[0]; inat=np.copy(np.array(inat[ind]))
    ilat=np.copy(np.array(ilat[ind]).astype('float')); ilon=np.copy(np.array(ilon[ind]).astype('float'))
    ity=np.copy(np.array(ity[ind]).astype('int')); itm=np.copy(np.array(itm[ind]).astype('int'))
    itd=np.copy(np.array(itd[ind]).astype('int')); ith=np.copy(np.array(ith[ind]).astype('int'))
    icyid=np.copy(np.array(icyid[ind])); iname=np.copy(np.array(iname[ind]))
    del ind; it=[]
    for i in range(0,np.size(ity)):
        it = np.append(it,np.array(timegm( time.strptime(repr(ity[i])+str(itm[i]).zfill(2)+str(itd[i]).zfill(2)+str(ith[i]).zfill(2), '%Y%m%d%H') )).astype('double'))

    # -----------

    # Calculate heading, for later rotation and definition of sectors.
    icbearing = ity*np.nan
    uyr=np.unique(ity)
    for i in range(0,len(uyr)):
        indy=np.where(ity==uyr[i])[0]
        un_icyid = np.unique(icyid[indy])
        for j in range(0,len(un_icyid)):
            indc1 = np.where(icyid[indy]==un_icyid[j])[0]
            alat=ilat[indy[indc1]]; alon=ilon[indy[indc1]]
            icbearing[indy[indc1]] = np.array(cbearing(alat,alon)).astype('float')
            del indc1

        del indy, un_icyid

    # -----------

    # resolution
    gres=np.diff(latm).mean()
    # displacement for the cyclone area
    dglat = int(np.ceil(((etr/100.)+1.0)/gres))
    # Final array of mask
    cmask=np.zeros((ftime.shape[0],maskm.shape[0],maskm.shape[1]),'i')
    # Sector
    csector=np.zeros((ftime.shape[0],maskm.shape[0],maskm.shape[1]),'f')
    # unique cyclone names
    cnameid=np.zeros((ftime.shape[0],maskm.shape[0],maskm.shape[1]),'f')-1.
    cnames=np.unique(iname) # 98 named cyclones inside the area.

    ct=0
    indtok=[]
    # loop through all times
    for t in range(0,ftime.shape[0]):
        cmask[t,:,:]=cmask[t,:,:]*maskm
        # search for cyclones on that time
        # Tropical cyclones
        indt = np.where( (it>=(ftime[t]-5401)) & (it<=(ftime[t]+5401)) )
        if np.size(indt)>0.:
            ct=ct+1
            indtok=np.append(indtok,int(t))
            # if cyclones found (one or more), loop through cyclones
            indt=np.array(indt[0]).astype('int')
            for i in range(0,indt.shape[0]):
                # center of the cyclone
                indilat=np.where( np.abs(latm-ilat[indt[i]])==np.min(np.abs(latm-ilat[indt[i]])) )[0][0]
                indilon=np.where( np.abs(lonm-ilon[indt[i]])==np.min(np.abs(lonm-ilon[indt[i]])) )[0][0]

                # Index of grid points whithin the cyclone
                rlat=np.array(np.where( (latm>=latm[indilat]-gres*dglat) & (latm<=latm[indilat]+gres*dglat) )[0]).astype('int')
                dglon = int(np.ceil((etr/(90./(1/np.cos(np.abs(latm)[int(np.round(np.mean(rlat)))]*(pi/180)))))/gres))
                rlon=np.array(np.where( (lonm>=lonm[indilon]-gres*dglon) & (lonm<=lonm[indilon]+gres*dglon) )[0]).astype('int')
                if np.abs(ilat[indt[i]])<40.:
                    etrl= tcr + np.max([0,np.abs(ilat[indt[i]])-20.])*(etr-tcr)/20.
                else:
                    etrl=etr

                cnid=np.where(cnames==iname[indt[i]])[0]

                aux_csector = np.zeros((len(rlat),len(rlon)),'f')
                for j in range(0,rlat.shape[0]):
                    for k in range(0,rlon.shape[0]):
                        cdist=float(geopy.distance.great_circle((latm[rlat[j]],lonm[rlon[k]]), (latm[indilat],lonm[indilon]) ).kilometers)
                        if cdist<=etrl:

                            # Sector
                            if rlat[j]>=indilat and rlon[k]>indilon:
                                aux_csector[j,k]=int(1)
                            elif rlat[j]>=indilat and rlon[k]<=indilon:
                                aux_csector[j,k]=int(2)
                            elif rlat[j]<indilat and rlon[k]<=indilon:
                                aux_csector[j,k]=int(3)
                            elif rlat[j]<indilat and rlon[k]>indilon:
                                aux_csector[j,k]=int(4)

                            # Cyclone name ID
                            cnameid[t,rlat[j],rlon[k]]=int(cnid)

                            if maskm[rlat[j],rlon[k]]>=0.:

                                if inat[indt[i]]=='TS':
                                    cmask[t,rlat[j],rlon[k]]=int(5)
                                elif inat[indt[i]]=='SS':
                                    cmask[t,rlat[j],rlon[k]]=int(4)
                                elif inat[indt[i]]=='ET':
                                    cmask[t,rlat[j],rlon[k]]=int(3)
                                elif inat[indt[i]]=='DS':
                                    cmask[t,rlat[j],rlon[k]]=int(2)
                                else:
                                    cmask[t,rlat[j],rlon[k]]=int(1)

                        del cdist

                # Rotate aux_csector
                b_csector = np.zeros((len(rlat),len(rlon)),'f')
                b_csector[:,:] = rotate_field(aux_csector, latm[rlat], lonm[rlon], icbearing[indt[i]])
                for j in range(0,rlat.shape[0]):
                    for k in range(0,rlon.shape[0]):
                        if b_csector[j,k] > 0.:
                            csector[t, rlat[j], rlon[k]] = b_csector[j,k]

                del aux_csector,rlat,rlon,indilat,indilon,cnid,etrl

            del indt

        print('  t : '+repr(t)+'   of '+repr(ftime.shape[0]))

    print(" ")
    print(" Total of "+str(np.round(100*(ct/ftime.shape[0]),2))+"% of time in these 3 years with cyclone")
    # Total of 36.42% of time in these 3 years with cyclone

    # Save only dates with cyclones
    indtok=np.array(indtok).astype('int')
    ftime=ftime[indtok]
    cmask=cmask[indtok,:,:]; csector=csector[indtok,:,:]; cnameid=cnameid[indtok,:,:]
    print(" Selected dates with active cyclones only")

    # Save .txt unique cyclone names
    df = pd.DataFrame(cnames, columns=['cyclone_names'])
    df.to_csv('cyclone_names.txt', index=False, header=False)

    # Save netcdf
    csector[csector<0.]=-1.; csector=np.array(csector).astype('int')
    cnameid[cnameid<0.]=-1.; cnameid=np.array(cnameid).astype('int')
    cmask[cmask<0.]=-1; 
    ncfile = nc.Dataset('CycloneMap.nc', "w", format=fnetcdf) 
    ncfile.history='Cyclone Map using IBtracks cyclone tracks, with same grid resolution as GEFSv12 winds.'
    ncfile.info='IDs: 0(no cyclone); 1(Missing,conflicting,or not reported); 2(disturbance); 3(extratropical); 4(subtropical storm/cyclone); 5(tropical storm/cyclone)'
    # create  dimensions.
    ncfile.createDimension('time', ftime.shape[0])
    ncfile.createDimension('lat', latm.shape[0])
    ncfile.createDimension('lon', lonm.shape[0])
    # Model results
    vcmap = ncfile.createVariable('cmap',np.dtype('int32'),('time','lat','lon'))
    vcsec = ncfile.createVariable('csec',np.dtype('int32'),('time','lat','lon'))
    vcid = ncfile.createVariable('cid',np.dtype('int32'),('time','lat','lon'))
    #
    vt = ncfile.createVariable('time',np.dtype('float64'),('time'))
    vlat = ncfile.createVariable('lat',np.dtype('float32'),('lat',))
    vlon = ncfile.createVariable('lon',np.dtype('float32'),('lon'))
    # Units
    vlat.units = 'degrees_north' ; vlon.units = 'degrees_east'
    vt.units = "seconds since 1970-01-01 00:00:00.0 0:00"
    # Allocate Data
    vt[:] = ftime[:]; vlat[:] = latm[:]; vlon[:] = lonm[:]
    vcmap[:,:,:] = cmask; vcsec[:,:,:] = csector; vcid[:,:,:] = cnameid
    ncfile.close()
    print('netcdf ok ')

