#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
gridSatGlobal_Altimeter.py

VERSION AND LAST UPDATE:
 v1.0  04/04/2022
 v1.1  07/18/2022
 v1.2  05/21/2023

PURPOSE:
 Script to take altimeter tracks and collocate into regular
  lat/lon grid (gridInfo.nc, generated by preprGridMask.py)
  and hourly time interval (for different time intervals, edit atime array)
 Here it uses the 'nearest' method.
 Cyclone information, from CycloneMap.nc, is also included in the output file.
 A total of 17 satellite missions are listed below. The period of each
  altimeter can be verified at:
  https://www.sciencedirect.com/science/article/pii/S0273117721000594
  https://ars.els-cdn.com/content/image/1-s2.0-S0273117721000594-gr1_lrg.jpg

USAGE:
 This program processes one satellite mission per run, entered as 
  argument (only the ID, sys.argv), see the sdname for the list of 
  altimeters available.
 To segment and paralelize it, the user can enter the number of segments (nseg)
  and the specific slice run (seg).
 Altimeters must have been previously downloaded (see wfetchsatellite_AODN_Altimeter.sh)
 Path where altimeter data is saved must be informed and 
  edited (see dirs below)
 Check the pre-selected parameters below for the altimeter collocation 
  and date interval (datemin and datemax)
 Example (from linux terminal command line):
  An example for JASON3 (first in the sdname list) is
   nohup python3 gridSatGlobal_Altimeter.py 0 >> nohup_sat0.out 2>&1 &
   python3 gridSatGlobal_Altimeter.py 0 10 1

OUTPUT:
 netcdf file AltimeterGridded_*.nc containing the collocated altimeter
  data into lat/lon grid points given by gridInfo.nc
 hsk: significant wave height, Ku or Ka altimeter band.
 wnd: 10-meter wind speed.
 'cal' means calibrated by IMOS-AODN.

DEPENDENCIES:
 See setup.py and the imports below.
 AODN altimeter data previously downloaded (see wfetchsatellite_AODN_Altimeter.sh)
 gridInfo.nc, generated by preprGridMask.py
  pay attention to longitude standards (-180to180 or 0to360), corrected by shiftgrid

AUTHOR and DATE:
 04/04/2022: Ricardo M. Campos, first version.
 07/18/2022: Ricardo M. Campos, SENTINEL-3B included. Longitude standard checked.
 05/21/2023: Ricardo M. Campos, CFOSAT included. HsC-band removed. New dlim default
  obtained from https://doi.org/10.3390/rs15082203
 10/30/2025: Adapted to collocate into a high-res grid using nearest method, and divided
  into segment to allow running multiple processes.

PERSON OF CONTACT:
 Ricardo M Campos: ricardo.campos@noaa.gov

"""

import numpy as np
import pandas as pd
import os
import netCDF4 as nc
import time
import timeit
from calendar import timegm
import sys
import warnings; warnings.filterwarnings("ignore")
# netcdf format
fnetcdf="NETCDF4"

if __name__ == "__main__":

# 20827762

    # INPUTS 
    # power of initial array 10**pia (size) that will be used to allocate satellite data (faster than append)
    pia=10
    # Maximum temporal distance (s) for pyresample weighted average
    maxti=1800.
    # Data intervall of the final array (original time is also saved)
    wdt = 3600.
    # Directory where AODN altimeter data is saved, downloaded using wfetchsatellite_AODN_Altimeter.sh
    dirs='/work/noaa/marine/ricardo.campos/data/AODN/altimeter'
    # Water depth (m) and distance to the coast (km) - for altimeter
    mdepth=80; mdfc=25

    # Date interval
    datemin='2022010100'; datemax='2025010100'

    # Satellite missions available at AODN dataset, pick one as this code runs one satellite at a time!
    if len(sys.argv) <= 2 :
        s=int(sys.argv[1]) # argument satellite ID for satellite mission selection. 
        # s=0 is JASON3, s=1 is JASON2 etc. See list below in sdname
    else:
        s=int(sys.argv[1])
        nseg=int(sys.argv[2])
        seg=int(sys.argv[3])

    sdname=np.array(['JASON3','JASON2','CRYOSAT2','JASON1','HY2','HY2B','SARAL','SENTINEL3A','ENVISAT','ERS1','ERS2','GEOSAT','GFO','TOPEX','SENTINEL3B','CFOSAT','SENTINEL6A'])
    sname=np.array(['JASON-3','JASON-2','CRYOSAT-2','JASON-1','HY-2','HY-2B','SARAL','SENTINEL-3A','ENVISAT','ERS-1','ERS-2','GEOSAT','GFO','TOPEX','SENTINEL-3B','CFOSAT','SENTINEL-6A'])
    # Ongoing sat missions:
    # CFOSAT, SARAL, CRYOSAT2, HY2B, JASON3, SENTINEL3A, SENTINEL3B, SENTINEL6A

    # Altimeter Quality Control parameters
    max_swh_rms = 1.5  # Max RMS of the band significant wave height
    max_sig0_rms = 0.8 # Max RMS of the backscatter coefficient
    max_swh_qc = 2.0 # Max SWH Ku band quality control
    hsmax=20.; wspmax=90.
    min_swh_numval = np.array([17,17,17,17,17,17,17,17,17,17,17,-9999,3,7,17,-9999,17])
    # ---------

    start = timeit.default_timer()

    # GridMask
    f=nc.Dataset('gridInfo.nc')
    latm=f.variables['latitude'][:]; lonm=f.variables['longitude'][:]
    maskm=f.variables['mask'][:,:]; depthm=f.variables['depth'][:,:]; dfc=f.variables['distcoast'][:,:]
    f.close(); del f
    # Cyclone Info
    f = nc.Dataset('CycloneMap.nc')
    latc=f.variables['lat'][:]; lonc=f.variables['lon'][:]; lonc[lonc<=0]=lonc[lonc<=0]+360.
    ctime = np.array(f.variables['time'][:]).astype('double')
    cmap = np.array(f.variables['cmap'][:,:,:]).astype('float')
    csec = np.array(f.variables['csec'][:,:,:]).astype('float')
    cid = np.array(f.variables['cid'][:,:,:]).astype('float')
    f.close(); del f

    print(" Processing segment "+str(seg)+" of total "+str(nseg)+". SAT "+sdname[s])

    # Date interval for satellite data allocation
    adatemin= np.double(  (timegm( time.strptime(datemin, '%Y%m%d%H') )-float(timegm( time.strptime('1985010100', '%Y%m%d%H') ))) /(24.*3600.) )
    adatemax= np.double(  (timegm( time.strptime(datemax, '%Y%m%d%H') )-float(timegm( time.strptime('1985010100', '%Y%m%d%H') ))) /(24.*3600.) )

    # Read Sat Data -----------------
    #  domain of interest
    auxlat=np.array(np.arange(np.floor(latm.min())-1.,np.ceil(latm.max())+1.,1)).astype('int')
    alonm=np.copy(lonm); alonm[alonm<0.]=alonm[alonm<0.]+360.
    auxlon=np.array(np.arange(np.floor(alonm.min())-1.,np.ceil(alonm.max())+1.,1)).astype('int')

    # Read and allocate satellite data into arrays
    ast=np.double(np.zeros((10**pia),'d')); aslat=np.zeros((10**pia),'f'); aslon=np.zeros((10**pia),'f')
    ahskcal=np.zeros((10**pia),'f')
    awndcal=np.zeros((10**pia),'f'); asig0knstd=np.zeros((10**pia),'f')
    aswhknobs=np.zeros((10**pia),'f'); aswhknstd=np.zeros((10**pia),'f'); aswhkqc=np.zeros((10**pia),'f')
    ii=0
    for j in auxlat:
        for k in auxlon:

            if j>=0:
                hem='N'
            else:
                hem='S'

            try: 
                fu=nc.Dataset(dirs+'/'+sdname[s]+'/IMOS_SRS-Surface-Waves_MW_'+sname[s]+'_FV02_'+str(np.abs(j)).zfill(3)+hem+'-'+str(k).zfill(3)+'E-DM00.nc')
            except:
                print(dirs+'/'+sdname[s]+'/IMOS_SRS-Surface-Waves_MW_'+sname[s]+'_FV02_'+str(np.abs(j)).zfill(3)+hem+'-'+str(k).zfill(3)+'E-DM00.nc does not exist'); vai=0
            else:
                st=np.double(fu.variables['TIME'][:])
                if np.size(st)>10:
                    slat=fu.variables['LATITUDE'][:]
                    slon=fu.variables['LONGITUDE'][:]
                    wndcal=fu.variables['WSPD_CAL'][:]
                    try: 
                        hskcal=fu.variables['SWH_KU_CAL'][:]
                        sig0knstd=fu.variables['SIG0_KU_std_dev'][:]
                        swhknobs=fu.variables['SWH_KU_num_obs'][:]
                        swhknstd=fu.variables['SWH_KU_std_dev'][:]
                        swhkqc=fu.variables['SWH_KU_quality_control'][:]
                    except:
                        print(' error reading KU, pick KA')
                        hskcal=fu.variables['SWH_KA_CAL'][:]
                        sig0knstd=fu.variables['SIG0_KA_std_dev'][:]
                        swhknobs=fu.variables['SWH_KA_num_obs'][:]
                        swhknstd=fu.variables['SWH_KA_std_dev'][:]
                        swhkqc=fu.variables['SWH_KA_quality_control'][:]

                    if ii+np.size(st) <= ast.shape[0] :
                        if (st.shape[0]==wndcal.shape[0]) & (slat.shape[0]==slon.shape[0]) & (wndcal.shape[0]==hskcal.shape[0]) :    
                            ast[ii:ii+st.shape[0]]=np.array(st).astype('double')
                            aslat[ii:ii+st.shape[0]]=np.array(slat).astype('float')
                            aslon[ii:ii+st.shape[0]]=np.array(slon).astype('float')
                            ahskcal[ii:ii+st.shape[0]]=np.array(hskcal).astype('float')
                            awndcal[ii:ii+st.shape[0]]=np.array(wndcal).astype('float')
                            asig0knstd[ii:ii+st.shape[0]]=np.array(sig0knstd).astype('float')
                            aswhknobs[ii:ii+st.shape[0]]=np.array(swhknobs).astype('float')
                            aswhknstd[ii:ii+st.shape[0]]=np.array(swhknstd).astype('float')
                            aswhkqc[ii:ii+st.shape[0]]=np.array(swhkqc).astype('float')
                            ii=ii+st.shape[0]

                    else:
                        sys.exit('Small array to allocate the satellite data! Increase the power of initial array (pia)')

                    del st,slat,slon,hskcal,wndcal,sig0knstd,swhknobs,swhknstd,swhkqc
                    fu.close(); del fu

    print(' Done reading and allocating satellite data '+sdname[s])
    del ii

    adatemin= np.double(  ( (timegm( time.strptime(datemin, '%Y%m%d%H'))-3600.) -float(timegm( time.strptime('1985010100', '%Y%m%d%H') ))) /(24.*3600.) )
    adatemax= np.double(  ( (timegm( time.strptime(datemax, '%Y%m%d%H'))+3600.) -float(timegm( time.strptime('1985010100', '%Y%m%d%H') ))) /(24.*3600.) )

    # Quality Control Check ----
    indq = np.where( (aswhknstd<=max_swh_rms) & (asig0knstd<=max_sig0_rms) & (aswhknobs>=min_swh_numval[s]) & (aswhkqc<=max_swh_qc) &
        (ahskcal>0.1) & (ahskcal<hsmax) & (awndcal>0.2) & (awndcal<wspmax) & (ast>=adatemin) & (ast<=adatemax) &
        (aslat>=(latm.min()-0.05)) & (aslat<=(latm.max()+0.05)) & (aslon>=(lonm.min()-0.05)) & (aslon<=(lonm.max()+0.05)) )

    del asig0knstd,aswhknobs,aswhknstd,aswhkqc,adatemin,adatemax

    if np.size(indq)>10:
        ii=0
        ast=np.double(np.copy(ast[indq[0]]))
        ast=np.double(np.copy(ast)*24.*3600.+float(timegm( time.strptime('1985010100', '%Y%m%d%H') )))
        aslat=np.copy(aslat[indq[0]]); aslon=np.copy(aslon[indq[0]])
        ahskcal=np.copy(ahskcal[indq[0]])
        awndcal=np.copy(awndcal[indq[0]])

        initime = (round(ast.min() / 3600) * 3600)-3600.
        fintime = (round(ast.max() / 3600) * 3600)+3600.
        aftime = np.array(np.arange(float(initime),float(fintime)+1,wdt)).astype('double')

        ftime=[]; frtime=[]
        lat=[]; lon=[]; gidlat=[]; gidlon=[]
        hs=[]; wnd=[]
        bcmap=[]; bcid=[]; bcsec=[]

        lines_to_read = len(ast) // nseg
        if seg<nseg:
            t1 = (seg-1)*lines_to_read
            t2 = (seg)*lines_to_read
        else:
            t1 = (seg-1)*lines_to_read
            t2 = len(ast)

        # for t in range(0,len(ast)):
        for t in range(t1,t2):

            # organize time, check mask (remove coastal areas), and allocate data
            indlat = np.where( np.abs(latm-aslat[t]) == np.nanmin(np.abs(latm-aslat[t])) )[0][0]
            indlon = np.where( np.abs(lonm-aslon[t]) == np.nanmin(np.abs(lonm-aslon[t])) )[0][0]
            indt=np.where(np.abs(ast[t]-aftime)<=1800.)  

            if (np.size(indt)>0) and (maskm[indlat,indlon]>=0.) and (depthm[indlat,indlon]>=mdepth) and (depthm[indlat,indlon]>=mdfc) :

                indt=np.min(indt)

                hs = np.append(hs,ahskcal[t])
                wnd = np.append(wnd,awndcal[t])
                ftime = np.append(ftime,np.double(ast[t]))
                frtime = np.append(frtime,np.double(aftime[indt]))

                lat=np.append(lat,latm[indlat])
                lon=np.append(lon,lonm[indlon])

                gidlat = np.append(gidlat,int(indlat))
                gidlon = np.append(gidlon,int(indlon))

                # check cyclone presence
                indc=np.where(np.abs(ctime-ast[t])<=5400.)
                if np.size(indc)>0:
                    indlatc = np.where( np.abs(latc-aslat[t]) == np.nanmin(np.abs(latc-aslat[t])) )[0][0]
                    indlonc = np.where( np.abs(lonc-aslon[t]) == np.nanmin(np.abs(lonc-aslon[t])) )[0][0]
                    if cmap[np.min(indc[0]),indlatc,indlonc]>0:
                        bcmap = np.append(bcmap,int(cmap[np.min(indc[0]),indlatc,indlonc]))
                        bcid = np.append(bcid,int(cid[np.min(indc[0]),indlatc,indlonc]))
                        bcsec = np.append(bcsec,int(csec[np.min(indc[0]),indlatc,indlonc]))
                    else:
                        bcmap = np.append(bcmap,0)
                        bcid = np.append(bcid,0)
                        bcsec = np.append(bcsec,0)

                    del indlatc, indlonc

                else:
                    bcmap = np.append(bcmap,0)
                    bcid = np.append(bcid,0)
                    bcsec = np.append(bcsec,0)

                del indc

            del indt, indlat, indlon
            # print(repr(t))

    # Save results
    ind=np.where(hs>0.01)
    if np.size(ind)>0:

        bid=np.full(len(hs), sdname[s], dtype=f'<U{len(sdname[s])}')

        hs[np.isnan(hs)==True]=-999.999; wnd[np.isnan(wnd)==True]=-999.999
        tm = np.full(len(hs), -999.999, dtype='float')
        tp = np.full(len(hs), -999.999, dtype='float')

        hs=np.round(hs,4); tp=np.round(tp,4); tm=np.round(tm,4); wnd=np.round(wnd,4)
        lat=np.round(lat,5); lon=np.round(lon,5)
        gidlat=np.array(gidlat).astype('int'); gidlon=np.array(gidlon).astype('int')
        bcmap=np.array(bcmap).astype('int'); bcid=np.array(bcid).astype('int'); bcsec=np.array(bcsec).astype('int')

        # Save wdics 
        df = pd.DataFrame({
            'time': pd.to_datetime(frtime, unit='s').strftime('%Y%m%d%H%M'),
            'altimeter_time': pd.to_datetime(ftime, unit='s').strftime('%Y%m%d%H%M'),
            'lat': lat,
            'lon': lon,
            'gidlat': gidlat,
            'gidlon': gidlon,
            'id': bid,
            'cmap': bcmap,
            'csec': bcsec,
            'cid': bcid,
            'hs': hs,
            'tm': tm,
            'tp': tp,
            'wnd': wnd
        })

        fname="Data_Altimeter_"+sdname[s]+"_"+str(seg).zfill(2)+"_"+str(nseg).zfill(2)+".txt"
        if seg==1:
            df.to_csv(fname, sep='\t', index=False, header=True)
        else:
            df.to_csv(fname, sep='\t', index=False, header=False)

    print(' ')
    stop = timeit.default_timer()
    print('Concluded in '+repr(int(round(stop - start,0)))+' seconds')

